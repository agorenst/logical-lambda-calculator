
Lambda calculus is a fascinating model of computation.
First-order predicate logic, as realized by Prolog, is also a fascinating model.

Let's explore lambda calculus with first-order predicate logic.
We will follow a simply wonderful book on lambda calculus\cite{lambdacalc} that builds up a complete model of computation from square 1.
An excellent work on viewing computation through a logical lense\cite{artofprolog} will arm us with the tools to do this.

Computation can be expressed in many different paradigms, the two most common being ``imperative'' and ``declarative''.
Roughly, computation is expressed \emph{imperatively} as an explicit sequence of steps a machine should undertake to perform the computation.
This implies that there is some set of fixed \emph{instructions}, the ways of storing and manipulating \emph{values} in \emph{locations}.
The correct sequence of instructions can be \emph{executed} to manipulate the initial values to ultimately compute the desired value.
This is the model (broadly) used by the most common programming languages--C, C++, C\#, Java, Python--and continues to appear in newer languages, such as Rust.
Of course, this is also the ultimate model provided by physical computers.\footnote{Ignoring some fascinating exceptions.}

Computation is expressed \emph{declaratively} as a set of relationships between values.
With some way of expressing those relationships, there is also an implied semantics behind those relationships.
Functional languages (such as Haskell) enable users to declare many \emph{functions} on data, and to actually do the computation those functions are \emph{applied} on the input.
Logical languages (such as Prolog) enable users to declare many facts, or \emph{sentences} on data.
To actually do the computation those sentences are \emph{resolved} to answer the input question.
In practice, declarative languages are executed by abstract machines, those machines are themselves defined in declarative terms so that they may run on physical machines.

Fundamentally, these paradigms and models all enable the same thing: computation.
The declarative model is more removed from the physical machine (and so in practice may induce concessions to performance), but open the door to more.

A \emph{declarative} expression of computation defines a large set of relationships between functions and values.
There is some underlying fundamental action that uses these relationships that expresses the computation to be done.

Shapiro does prolog to imperative.

This can also serve as an introduction to prolog.